/**
 * SED - Semantic Entropy Differencing
 * GitHub Action Formatters
 * Copyright (C) 2026 Stevo (sgbilod)
 * @license MIT
 */

import type { AnalysisResult } from './types';

const CLASSIFICATION_EMOJI: Record<string, string> = {
  trivial: 'âœ…',
  low: 'ğŸ’š',
  medium: 'ğŸ’›',
  high: 'ğŸŸ ',
  critical: 'ğŸ”´',
};

const CLASSIFICATION_COLOR: Record<string, string> = {
  trivial: '#10b981',
  low: '#3b82f6',
  medium: '#f59e0b',
  high: '#f97316',
  critical: '#ef4444',
};

/**
 * Format analysis result as a Markdown report
 */
export function formatMarkdownReport(analysis: AnalysisResult): string {
  const lines: string[] = [];

  lines.push('# SED Analysis Report');
  lines.push('');
  lines.push(`**Commit Range:** \`${analysis.from}\` â†’ \`${analysis.to}\``);
  lines.push(`**Timestamp:** ${analysis.timestamp}`);
  lines.push('');

  // Summary table
  lines.push('## Summary');
  lines.push('');
  lines.push('| Metric | Value |');
  lines.push('|--------|-------|');
  lines.push(`| Files Analyzed | ${analysis.summary.totalFiles} |`);
  lines.push(`| Total Entropy | ${analysis.summary.totalEntropy.toFixed(2)} |`);
  lines.push(`| Average Entropy | ${analysis.summary.averageEntropy.toFixed(2)} |`);
  lines.push('');

  // Classification distribution
  lines.push('## Classification Distribution');
  lines.push('');
  lines.push('| Classification | Count |');
  lines.push('|----------------|-------|');
  Object.entries(analysis.summary.classifications).forEach(([cls, count]) => {
    lines.push(`| ${CLASSIFICATION_EMOJI[cls]} ${cls} | ${count} |`);
  });
  lines.push('');

  // Files with highest entropy
  if (analysis.files.length > 0) {
    lines.push('## Highest Entropy Files');
    lines.push('');
    lines.push('| File | Entropy | Classification |');
    lines.push('|------|---------|----------------|');

    analysis.files
      .sort((a, b) => b.entropy - a.entropy)
      .slice(0, 10)
      .forEach((file) => {
        const emoji = CLASSIFICATION_EMOJI[file.classification];
        lines.push(
          `| \`${file.relativePath}\` | ${file.entropy.toFixed(2)} | ${emoji} ${file.classification} |`
        );
      });
    lines.push('');
  }

  lines.push('---');
  lines.push('*Generated by [SED - Semantic Entropy Differencing](https://github.com/sgbilod/sed)*');

  return lines.join('\n');
}

/**
 * Format analysis result as a PR comment
 */
export function formatPRComment(analysis: AnalysisResult): string {
  const lines: string[] = [];

  lines.push('<!-- SED Analysis -->');
  lines.push('## ğŸ” SED Analysis Results');
  lines.push('');

  // Determine overall status
  const avgEntropy = analysis.summary.averageEntropy;
  let status: string;
  let statusEmoji: string;

  if (avgEntropy < 0.5) {
    status = 'trivial';
    statusEmoji = 'âœ…';
  } else if (avgEntropy < 1.5) {
    status = 'low';
    statusEmoji = 'ğŸ’š';
  } else if (avgEntropy < 3.0) {
    status = 'medium';
    statusEmoji = 'ğŸ’›';
  } else if (avgEntropy < 4.5) {
    status = 'high';
    statusEmoji = 'ğŸŸ ';
  } else {
    status = 'critical';
    statusEmoji = 'ğŸ”´';
  }

  lines.push(`${statusEmoji} **Overall: ${status.toUpperCase()}**`);
  lines.push('');

  // Quick stats
  lines.push('### ğŸ“Š Summary');
  lines.push('');
  lines.push(`| Metric | Value |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Files Analyzed | ${analysis.summary.totalFiles} |`);
  lines.push(`| Total Entropy | ${analysis.summary.totalEntropy.toFixed(2)} |`);
  lines.push(`| Average Entropy | ${analysis.summary.averageEntropy.toFixed(2)} |`);
  lines.push('');

  // Classification breakdown
  const hasCritical = analysis.summary.classifications.critical > 0;
  const hasHigh = analysis.summary.classifications.high > 0;

  if (hasCritical || hasHigh) {
    lines.push('### âš ï¸ Attention Required');
    lines.push('');
    if (hasCritical) {
      lines.push(`- ğŸ”´ **${analysis.summary.classifications.critical}** files with critical entropy`);
    }
    if (hasHigh) {
      lines.push(`- ğŸŸ  **${analysis.summary.classifications.high}** files with high entropy`);
    }
    lines.push('');
  }

  // Top files
  if (analysis.files.length > 0) {
    lines.push('<details>');
    lines.push('<summary>ğŸ“ Top Entropy Files (click to expand)</summary>');
    lines.push('');
    lines.push('| File | Entropy | Classification |');
    lines.push('|------|---------|----------------|');

    analysis.files
      .sort((a, b) => b.entropy - a.entropy)
      .slice(0, 10)
      .forEach((file) => {
        const emoji = CLASSIFICATION_EMOJI[file.classification];
        lines.push(
          `| \`${file.relativePath}\` | ${file.entropy.toFixed(2)} | ${emoji} ${file.classification} |`
        );
      });

    lines.push('');
    lines.push('</details>');
    lines.push('');
  }

  lines.push('---');
  lines.push('<sub>ğŸ¤– Generated by SED - Semantic Entropy Differencing</sub>');

  return lines.join('\n');
}

/**
 * Format analysis result as a compact summary
 */
export function formatCompactSummary(analysis: AnalysisResult): string {
  const { totalFiles, totalEntropy, averageEntropy } = analysis.summary;
  
  let classification: string;
  if (averageEntropy < 0.5) classification = 'trivial';
  else if (averageEntropy < 1.5) classification = 'low';
  else if (averageEntropy < 3.0) classification = 'medium';
  else if (averageEntropy < 4.5) classification = 'high';
  else classification = 'critical';

  return `SED: ${totalFiles} files | Total: ${totalEntropy.toFixed(2)} | Avg: ${averageEntropy.toFixed(2)} | ${classification.toUpperCase()}`;
}
